#include <AD7746.h>
#include <Wire.h>


#define address_0 12           // pin address for multiplexer address 0
#define address_1 11           // pin address for multiplexer address 1
#define address_2 10           // pin address for multiplexer address 2
#define multiplexer_addr 0x70

// Define default register values
#define Cap_Setup_1     0b10000000
#define Cap_Setup_2     0b11000000
#define EXC_Setup       0b00000111
#define Configuration   0b11111001
#define Cap_DAC_A       0b00011100
#define Cap_Offset_H    0x80
#define Cap_Offset_L    0x00

// Define serial commands
#define RC  1
#define RS  2
#define SC  3
#define OM  4
#define CT  5
#define CD  6
#define SO  7
#define CS  8

// const int message_len = 5;
// char message[message_len];
// char valid_message[5] = "data";
bool valid = false;
byte result;
uint32_t cap;
uint8_t stat;
char command[2];
int switchCase;
uint32_t reportedCap;
uint8_t reportedCapASCIIhex[6];
uint8_t reportedStatus;
uint8_t reportedStatusASCIIhex[2];
uint8_t reply[10];

// initialize sensor objects
AD7746 sensor;

void processSerialByte(uint8_t inByte)
{
  // static variables are only created and initialized the first
  // time the function is called
  static char message [10];
  static unsigned int i = 0;
  static bool readingMessage  = false;

  if (readingMessage)
  {
    message [i++] = inByte;
  }
  
  switch (inByte)
  {
  case '#':
    // reset the entire message array
    for (int i=0;i<10;i++)
    {
      message[i] = (char)0;
    }
    i = 0;
    readingMessage = true;
    message [i++] = inByte;
    break;
  case ';':
    decide(message);
    readingMessage = false;
    break;
  
  default:
    break;
  }
}

void parseCommand(const char message[10])
{
 Serial.print(F("uM received this message: "));
 Serial.println(message);
 switchCase = 0;
 command[0] = message[1];
 command[1] = message[2];
 if ((command[0] == 'R') && (command[1] == 'C'))
 {
   switchCase = RC;
 }
 else if ((command[0] == 'R') && (command[1] == 'S'))
 {
   switchCase = RS;
 }
 
}

void decide(const char message[10])
{
 parseCommand(message);
 switch (switchCase)
 {
 case RC:
   reportedCap = sensor.getCapacitance();
   ASCIIConvert(reportedCap,&reportedCapASCIIhex[0],6);
   buildMessageFrame(&reportedCapASCIIhex[0],&reply[0],8);
   writeSerialResponse(&reply[0],8);
   break;

 case RS:
   reportedStatus = sensor.reportStatus();
   ASCIIConvert(reportedStatus,&reportedStatusASCIIhex[0],2);
   buildMessageFrame(&reportedStatusASCIIhex[0],&reply[0],4);
   writeSerialResponse(&reply[0],4);
   break;
/*
 case "SC":
   sensor.writeCapSetupRegister(value);
   break;

 case "OM":
   sensor.writeConfigurationRegister(value);
   break;
 
 case "CT":
   sensor.writeConfigurationRegister(value);
   break;
 
 case "CD":
   sensor.writeCapDacARegister(value);
   break;
 
 case "SO":
   // sensor.write
   break;
 
 case "CS":
   break;
*/

 default:
   break;
 }
}

/* Takes the data to send in a message, and builds a frame around
it by adding a # at the start and a CR and LF at the end.*/
void buildMessageFrame(uint8_t *data,uint8_t *reply,uint8_t messageLength)
{
  // clear pre-existing reply
  for (int i=0;i<10;i++){
    *reply = 0;
    reply++;
  }

  reply -= 10;
  
  *reply = 0x23;
  reply++;
  for (int i=0;i<(messageLength-2);i++){
    *reply = *data;
    data++;
    reply++;
  }
  *reply = 0x3B;
}

void writeSerialResponse(uint8_t *response,uint8_t responseLength)
{
  for (int i=0;i<responseLength;i++){
    Serial.write(*response);
    response++;
  }
}

/* ASCIIConvert takes a 32 bit value and converts it to a the ASCII
values representing the characters which define the value in
HEX format.

Params
    value: the 32 bit value defined by the ADC on the AD7746
    *modified: a pointer to the array used to store the ASCII values
        representing the characters in the HEX representation of the
        value
    arraysize: the number of characters in the HEX representaiton of
        the value - 6 for the 24 bit value generated by the AD7746

Returns
    void

Example function call: ASCIIConvert(int value = 0x1234AF,int newvalue[6],6) */
void ASCIIConvert (uint32_t value,uint8_t *modified,int arraySize)
{
 int shiftValue;
 for (int i=0;i<arraySize;i++)
 {
   shiftValue = ((arraySize-1)*4-i*4);
   *modified = ((value & (0b00001111 << shiftValue)) >> shiftValue);
   if (*modified>9)
   {
     *modified += 55;
   }
   else
   {
     *modified += 48;
   }
   modified++;
 }
}

void setup() {
  // initiate serial connections
  Serial.begin(9600);
  Wire.begin();
  delay(250);
  
  // set multiplexer address
  pinMode(address_0,OUTPUT);
  pinMode(address_1,OUTPUT);
  pinMode(address_2,OUTPUT);
  digitalWrite(address_0,LOW);
  digitalWrite(address_1,LOW);
  digitalWrite(address_2,LOW);

  // set control registers
  sensor.writeCapSetupRegister(Cap_Setup_1);
  sensor.writeExcSetupRegister(EXC_Setup);
  sensor.writeConfigurationRegister(Configuration);
  sensor.writeCapDacARegister(Cap_DAC_A);
  
  // set up the multiplexer to communicate over channel 7
  Wire.beginTransmission(multiplexer_addr);
  Wire.write(0b10000000);
  result = Wire.endTransmission();
  if (result) {
    Serial.println(F("Failed to set multiplexer output channel."));
  }
  
}

void loop() {
//   stat = sensor.reportStatus();
//   cap = sensor.getCapacitance();
  
// //  Serial.print(F("Status byte is: "));
// //  Serial.println(stat,BIN);
// //  Serial.print(F("Cap is: "));
  
//   Serial.println(cap);
//   delay(100);

  while (Serial.available())
  {
    processSerialByte(Serial.read());
  }
}
