#include <AD7746.h>
#include <Wire.h>
#include <RingBufCPP.h>
#include <Task.h>


#define address_0 12           // pin address for multiplexer address 0
#define address_1 11           // pin address for multiplexer address 1
#define address_2 10           // pin address for multiplexer address 2
#define multiplexer_addr 0x70

// Define default register values
#define Cap_Setup_1     0b10000000
#define Cap_Setup_2     0b11000000
#define EXC_Setup       0b00000111
#define Configuration   0b11111001
#define Cap_DAC_A       0b00011100
#define Cap_Offset_H    0x80
#define Cap_Offset_L    0x00

// Define serial commands
#define RC  1
#define RS  2
#define RV  3
#define OM  4
#define CT  5
#define CD  6
#define SO  7
#define CS  8

struct sensorReading
{
  uint32_t value;
  uint8_t _sensorID;
  uint8_t _channelID;
  uint32_t timestamp;
};

// Define buffers and stuff
RingBufCPP<struct sensorReading,5> readingsBuffer;
RingBufCPP<class Task,20> taskBuffer;
uint8_t messageBuffer[200];

Task currentTask(1,1,1);
bool busFree = true;


// initialize sensor objects
AD7746 sensor;

void processSerialByte(uint8_t inByte)
{
  // static variables are only created and initialized the first
  // time the function is called
  static char message [10];
  static unsigned int i = 0;
  static bool readingMessage  = false;

  if (readingMessage)
  {
    message [i++] = inByte;
  }
  
  switch (inByte)
  {
  case '#':
    // reset the entire message array
    for (int i=0;i<10;i++)
    {
      message[i] = (char)0;
    }
    i = 0;
    readingMessage = true;
    message [i++] = inByte;
    break;
  case ';':
    busFree = true;
    readingMessage = false;
    buildTask(message);
    break;
  
  default:
    break;
  }
}

void buildTask(const char message[10])
{
 uint8_t taskID = parseCommand(message);
 // need to pull the sensorID and channelID from the message here
 uint8_t sensorID = message[3];
 uint8_t channelID = message[4]; 
 Task newTask(sensorID,channelID,taskID);
 taskBuffer.add(newTask);
}

uint8_t parseCommand(const char message[10])
{
 uint8_t command = 0;
 uint8_t charOne = message[1];
 uint8_t charTwo = message[2];
 if ((charOne == 'R') && (charTwo == 'C'))
 {
   command = RC;
 }
 else if ((charOne == 'R') && (charTwo == 'S'))
 {
   command = RS;
 }
 else if ((charOne == 'R') && (charTwo == 'V'))
 {
   command = RV;
 }
 return command;
}

void writeSerialResponse(uint8_t *response)
{
  while (true)
  {
    Serial.write(*response);
    if (*response == 59)
    {
      break;
    }
    response++;
  }
}

/* ASCIIConvert takes a 32 bit value and converts it to a the ASCII
values representing the characters which define the value in
HEX format.

Params
    value: the 32 bit value defined by the ADC on the AD7746
    *modified: a pointer to the array used to store the ASCII values
        representing the characters in the HEX representation of the
        value
    arraysize: the number of characters in the HEX representaiton of
        the value - 6 for the 24 bit value generated by the AD7746

Returns
    void

Example function call: ASCIIConvert(int value = 0x1234AF,int newvalue[6],6) */
void ASCIIConvert (uint32_t value,uint8_t *modified,int arraySize)
{
 int shiftValue;
 for (int i=0;i<arraySize;i++)
 {
   shiftValue = ((arraySize-1)*4-i*4);
   *modified = ((value & (0b00001111 << shiftValue)) >> shiftValue);
   if (*modified>9)
   {
     *modified += 55;
   }
   else
   {
     *modified += 48;
   }
   modified++;
 }
}

void setup() {
  // initiate serial connections
  Serial.begin(9600);
  Wire.begin();
  delay(250);
  
  // set multiplexer address
  pinMode(address_0,OUTPUT);
  pinMode(address_1,OUTPUT);
  pinMode(address_2,OUTPUT);
  digitalWrite(address_0,LOW);
  digitalWrite(address_1,LOW);
  digitalWrite(address_2,LOW);

  // set control registers
  sensor.writeExcSetupRegister(EXC_Setup);
  sensor.writeConfigurationRegister(Configuration);
  sensor.writeCapDacARegister(Cap_DAC_A);  
}

void loop() {
  
  // Receive input from the serial input buffer
  while (Serial.available())
  {
    busFree = false;
    processSerialByte(Serial.read());
  }
  
  // Perform any tasks which may be waiting
  while (taskBuffer.pull(&currentTask))
  {
    currentTask.executeTask();
  }
  
  // Add a message to serial out buffer if one is ready
  if (messageBuffer[0])
  {
    if (busFree)
    {
      writeSerialResponse(&messageBuffer[0]);
    }
  }
}
